//
// This source file is part of the Apodini open source project
//
// SPDX-FileCopyrightText: 2019-2021 Paul Schmiedmayer and the Apodini project authors (see CONTRIBUTORS.md) <paul.schmiedmayer@tum.de>
//
// SPDX-License-Identifier: MIT
//

import XCTest
@testable import BadLinguaWebService
@testable import ImprovedLinguaWebService
@testable import Apodini
import XCTApodiniNetworking
import ApodiniHTTPProtocol
import XCTApodini
import Shared
@testable import ApodiniAudit

/// Tests that the report generated by ApodiniAudit for the ``BadLinguaWebService`` lists the correct findings for the checkable best practices.
final class CheckableBPTests: XCTApodiniTest {
    static var audits: [Audit]!
    
    override class func setUp() {
        // Run the AuditSetupCommand to install NLTK. It doesn't matter which WebService we specify.
        let app = Application()
        let commandType = AuditSetupNLTKCommand<ImprovedLinguaWebService>.self
        let command = commandType.init()
        do {
            try command.run(app: app)
            print("Installed requirements!")
        } catch {
            print("Could not install requirements: \(error)")
        }
        
        let runcommandtype = AuditRunCommand<BadLinguaWebService>.self
        var runcommand = runcommandtype.init()
        
        do {
            audits = try getAuditsForAuditRunCommand(&runcommand).filter { $0.findings.count > 0 }
        } catch {
            fatalError("could not get audits: \(error)")
        }
    }
    
    override func setUpWithError() throws {
        try super.setUpWithError()
        

    }
    
    func testDeleteReturnTypeFinding() throws {
        let finding = try CheckableBPTests.getSingleFindingFromSingleAudit(
            bptype: EndpointHasComplexReturnType.self,
            findingType: ReturnTypeFinding.self,
            endpointPath: "/en/dictionary/entries/{entryId}",
            handlerName: "DeleteDictionaryEntryHandler"
        )
        XCTAssertEqual(finding, .hasPrimitiveReturnType(.delete))
    }
    
    func testTooManyParamsFinding() throws {
        let finding = try CheckableBPTests.getSingleFindingFromSingleAudit(
            bptype: ReasonableParameterCount.self,
            findingType: ParameterCountFinding.self,
            endpointPath: "/en/dictionary/entries",
            handlerName: "SearchDictionaryHandler"
        )
        XCTAssertEqual(finding, .tooManyParameters(count: 12))
    }
    
//    func test() throws {
//        let finding = try getSingleFindingFromSingleAudit(
//            bptype: ReasonableParameterCount.self,
//            findingType: ParameterCountFinding.self,
//            endpointPath: "/en/dictionary/entries",
//            handlerName: "SearchDictionaryHandler"
//        )
//        XCTAssertEqual(finding, .tooManyParameters(count: 12))
//    }
    
    private static func getSingleFindingFromSingleAudit<F: Finding>(
        bptype: BestPractice.Type,
        findingType: F.Type,
        endpointPath: String,
        handlerName: String,
        webServiceString: String = "BadLinguaWebService"
    ) throws -> F {
        XCTAssertEqual(audits.count(where: { type(of: $0.bestPractice) == bptype }), 1)
        let audit = try XCTUnwrap(audits.first(where: { type(of: $0.bestPractice) == bptype }))
        XCTAssertEqual(audit.findings.count, 1)
        XCTAssertEqual(audit.endpoint.absolutePath.pathString, endpointPath)
        XCTAssertEqual(audit.endpoint.bareHandlerName(webServiceString), handlerName)
        return try XCTUnwrap(audit.findings.first) as! F
    }
    
    private static func getAuditsForAuditRunCommand<T: WebService>(_ command: inout AuditRunCommand<T>) throws -> [Audit] {
        command.webService = .init()
        
        let app = Application()
        try command.run(app: app)
        
        // Get the AuditInterfaceExporter
        // FUTURE We just get the first one, for now we do not consider the case of multiple exporters
        let optionalExporter = app.interfaceExporters.first { exporter in
            exporter.typeErasedInterfaceExporter is AuditInterfaceExporter
        }
        let auditInterfaceExporter = try XCTUnwrap(optionalExporter?.typeErasedInterfaceExporter as? AuditInterfaceExporter)
        
        return auditInterfaceExporter.report.audits
    }
}
