//
// This source file is part of the Apodini open source project
//
// SPDX-FileCopyrightText: 2019-2021 Paul Schmiedmayer and the Apodini project authors (see CONTRIBUTORS.md) <paul.schmiedmayer@tum.de>
//
// SPDX-License-Identifier: MIT
//

import XCTest
@testable import BadLinguaWebService
@testable import ImprovedLinguaWebService
@testable import Apodini
import XCTApodiniNetworking
import ApodiniHTTPProtocol
import XCTApodini
import Shared
@testable import ApodiniAudit

/// Tests that the report generated by ApodiniAudit for the ``BadLinguaWebService`` lists the correct findings for the checkable best practices.
final class CheckableBPTests: XCTApodiniTest {
    var audits: [Audit]!
    
    override func setUpWithError() throws {
        try super.setUpWithError()
        
        let commandType = AuditRunCommand<BadLinguaWebService>.self
        var command = commandType.init()
        
        audits = try getAuditsForAuditRunCommand(&command).filter { $0.findings.count > 0 }
    }
    
    func testDeleteReturnTypeFinding() throws {
        let finding = try getSingleFindingFromSingleAudit(
            bptype: EndpointHasComplexReturnType.self,
            findingType: ReturnTypeFinding.self,
            endpointPath: "/en/dictionary/entries/{entryId}",
            handlerName: "DeleteDictionaryEntryHandler"
        )
        XCTAssertEqual(finding, .hasPrimitiveReturnType(.delete))
    }
    
    func testTooManyParamsFinding() throws {
        let finding = try getSingleFindingFromSingleAudit(
            bptype: ReasonableParameterCount.self,
            findingType: ParameterCountFinding.self,
            endpointPath: "/en/dictionary/entries",
            handlerName: "SearchDictionaryHandler"
        )
        XCTAssertEqual(finding, .tooManyParameters(count: 12))
    }
    
//    func test() throws {
//        let finding = try getSingleFindingFromSingleAudit(
//            bptype: ReasonableParameterCount.self,
//            findingType: ParameterCountFinding.self,
//            endpointPath: "/en/dictionary/entries",
//            handlerName: "SearchDictionaryHandler"
//        )
//        XCTAssertEqual(finding, .tooManyParameters(count: 12))
//    }
    
    private func getSingleFindingFromSingleAudit<F: Finding>(
        bptype: BestPractice.Type,
        findingType: F.Type,
        endpointPath: String,
        handlerName: String,
        webServiceString: String = "BadLinguaWebService"
    ) throws -> F {
        XCTAssertEqual(audits.count(where: { type(of: $0.bestPractice) == bptype }), 1)
        let audit = try XCTUnwrap(audits.first(where: { type(of: $0.bestPractice) == bptype }))
        XCTAssertEqual(audit.findings.count, 1)
        XCTAssertEqual(audit.endpoint.absolutePath.pathString, endpointPath)
        XCTAssertEqual(audit.endpoint.bareHandlerName(webServiceString), handlerName)
        return try XCTUnwrap(audit.findings.first) as! F
    }
    
    private func getAuditsForAuditRunCommand<T: WebService>(_ command: inout AuditRunCommand<T>) throws -> [Audit] {
        command.webService = .init()
        
        try command.run(app: app)
        
        // Get the AuditInterfaceExporter
        // FUTURE We just get the first one, for now we do not consider the case of multiple exporters
        let optionalExporter = app.interfaceExporters.first { exporter in
            exporter.typeErasedInterfaceExporter is AuditInterfaceExporter
        }
        let auditInterfaceExporter = try XCTUnwrap(optionalExporter?.typeErasedInterfaceExporter as? AuditInterfaceExporter)
        
        return auditInterfaceExporter.report.audits
    }
}
